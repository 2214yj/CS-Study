## 운영체제란 무엇이고, 무엇을 위해 만들었는지에 대해 설명해주세요.

<br>

💡 운영체제는 유저와 하드웨어 간의 인터페이스 역할을 하는 소프트웨어입니다. 

운영체제는 유용한 사용자 프로그램을 실행할 수 있는 환경을 제공하고, 하드웨어의 자원을 효율적으로 사용하기 위해 만들어졌습니다. 

이를 위해 프로세스 관리, 메모리 관리, 디스크관리, 입출력 장치 관리 등의 역할을 수행합니다.

<br><br><br>

## 시스템콜에 대해 설명해주세요.

<br>

💡 시스템 콜은 운영체제 서비스를 제공받기 위해 커널 모드로 전환하는 방법으로 일종의 소프트웨어 인터럽트입니다.

<br><br><br>

## 커널의 역할에 대해 설명하세요.

<br>

💡 프로세스 관리 및 CPU 관리, 메모리 관리, I/O 장치 관리, 파일 시스템 관리, 다른 컴퓨터와 연결하는 네트워크 역할을 합니다.

<br><br><br>

## 이중모드(유저모드와 커널모드)에 대해 설명해주세요.

<br>

💡 중요한 자원을 보호하기 위해, 응용 프로그램들이 자원에 접근하려고 할 때 **커널**을 통해서만 접근하도록 하여 자원을 보호합니다. 그리고 이는 **이중모드**로써 구현됩니다.

<br>

**이중모드**란 CPU가 명령어를 실행하는 모드를 크게 **사용자 모드**와 **커널 모드**로 구분하는 방식입니다.

**유저모드**는 사용자 애플리케이션이 실행되는 모드로 하드웨어 리소스에 접근할 수 없습니다.

**커널모드**는 모든 권한을 가진 실행 모드로 운영체제가 실행되는 모드입니다.

<br><br><br>

## CPU가 이중 모드를 사용하는 이유에 대해 설명하세요.

<br>

💡 응용 프로그램이 직접 자원에 접근하게 되면 하나의 실수로 프로그램 전체에 영향을 끼칠 수 있습니다. 

이런 문제가 발생하지 않게 하기 위해 이중 모드를 사용합니다.

<br><br><br>

## CPU 스케줄링 알고리즘이 필요한 이유가 무엇일까요?

<br>

💡 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하기 위해서 CPU 스케줄링 알고리즘이 필요합니다.

<br><br><br>

## 스택을 스레드마다 독립적으로 할당하는 이유가 무엇인가요?

<br>

💡 **스택**은 함수 호출 시 사용되는 인자, 리턴값 및 지역 변수 등을 저장하기 위해 사용되는 메모리 공간입니다. 

독립적인 함수 호출을 위해서 입니다.


<br><br><br>
## 스택을 스레드마다 독립적으로 할당하는 이유에 대해 설명해주세요.

<br>

💡 스레드를 비동기적으로 사용하기 위해서입니다. 

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소 값, 함수 내에서 선언하는 변수 등에 대한 정보를 저장하기 위해 사용되는 메모리 공간입니다. 

이 때문에 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고, 이는 독립적인 실행흐름을 가질 수 있다는 것입니다. 

스레드마다 스택을 따로 할당하면 독립적인 실행흐름, 즉 스레드를 비동기적으로 사용할 수 있습니다.

<br><br><br>

## 프로세스 간의 동기화(IPC) 방법에 대해 설명해주세요.

<br>

💡 IPC(Inter-Process Communication)의 방법으로는 크게 **공유 메모리 기법(Shared Memory)**과 **메시지 전달 기법(Message Passing)**이 있다.

<br>

**공유 메모리 기법**은 공유 메모리 영역을 통해 프로세스 간의 데이터를 교환하고 통신하는 방법이다. 공유 메모리기법은 중개자 없이 곧바로 메모리에 접근할 수 있기 때문에 비교적 더 빠르다.

**메시지 전달 기법**은 프로세스 간의 메시지를 교환하여 프로세스 간에 통신하는 방법이다. 대표적으로 시그널, 소켓, 파이프, 메시지 큐 등이 있다.

<br><br><br>

## 프로세스 동기화에 대해 설명해주세요.

<br>

💡 프로세스 동기화는 다중 프로세스 환경에서 자원에 한 프로세스만이 접근 가능하도록 하는 것입니다. 

프로세스 동기화를 하지 않으면 데이터의 일관성이 깨지기 때문에 연산 결과가 잘못 반환될 가능성이 있으므로 주의해야 합니다.

<br><br><br>

## 좀비 프로세스와 고아프로세스에 대해 설명해주세요.

<br>

💡 **좀비 프로세스**란 부모 함수가 wait 함수를 호출하지 않아, 메모리에 남아 있는 자식 프로세스를 뜻합니다. 

좀비 프로세스는 최소한의 정보만을 가지고 있어 큰 성능 저하를 야기하지 않지만, 운영체제는 한정된 PID를 가지고 있기 때문에 좀비 프로세스가 PID를 차지하여 다른 프로세스의 실행을 방해할 수 있습니다.

<br>

**고아 프로세스**란 부모 프로세스가 자식 프로세스보다 먼저 종료되어, 부모 프로세스가 없는 자식 프로세스를 의미합니다. 

운영체제는 이러한 프로세스를 허용하지 않기 때문에 부모 프로세스가 먼저 종료될 경우, 자식 프로세스의 새로운 부모 프로세스로 init(PID = 1)가 설정됩니다.

<br><br><br>

## 프로세스와 스레드의 차이에 대해 설명해주세요.

<br>

💡 프로세스는 실행중인 프로그램을 의미하고, 스레드는 프로세스의 작업 단위를 의미합니다. 

프로세스는 운영체제로부터 자원을 할당받고, 스레드는 프로세스로부터 자원을 할당받습니다. 


그리고 프로세는 메모리의 데이터/코드/힙/스택 영역을 독립적으로 가지고 있고, 스레드는 프로세스의 데이터/코드/힙 영역을 공유하고 있습니다. 때문에 스레드는 프로세스보다 좀 더 효율적으로 통신할 수 있습니다. 

하지만 스레드는 자원 공유로 인해 어느 한 스레드가 문제가 발생하며 스레드 전체에 영향을 끼칠 할 수 있으니 조심하여 프로그래밍 해야 합니다.


<br><br><br>

## 동기와 비동기 차이(블로킹, 넌블록킹) 장단점에 대해 설명해주세요.

<br>

💡 동기/비동기 방식은 함수들의 시간을 맞춰서 실행되느냐에 따라 구분됩니다. 


동기 방식은 함수들의 시간을 맞춰 실행됩니다. 함수에 요청을 보내놓고, 작업 완료 여부를 계속 확인한 다음 응답을 받으면 다른 작업을 시작하는 것입니다. 


비동기 방식은 반대로 언제 시작되고 언제 끝났는지 신경쓰지 않는 방식입니다. 따라서 여러 개의 처리가 함께 실행되고, 동기 방식에 비해 단위 시간 당 많은 작업의 처리를 할 수 있습니다. 

<br>

### 🤨 그렇다면 비동기 방식의 단점은 무엇인가요?
CPU나 메모리를 많이 사용하는 작업을 비동기로 처리하게 되면 과부하가 걸릴 수 있습니다.

<br>

블로킹과 논블로킹은 함수를 호출했을 때 제어권을 어떻게 처리하느냐에 대한 차이를 말합니다.

블로킹 방식은 호출된 함수의 작업이 끝날 때까지 제어권을 해당 함수가 가지고 있는 것을 의미하고, 논블로킹은 함수의 작업 여부와 상관없이 새로운 작업을 수행하는 것을 의미합니다.

<br><br><br>

## 가상 메모리에 대해 설명해주세요.

<br>

💡 가상 메모리는 프로세스가 실제 메모리 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술입니다. 

가상 메모리는 실제 메모리와 보조기억장치의 Swap 영역으로 구성됩니다. OS는 MMU를 통해 가상 주소인 논리주소를 물리주소로 변환하고, 메모리를 관리합니다.

<br><br><br>

## 컨텍스트 스위칭에 대해 설명해주세요.

<br>

💡 멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 다음 우선 순위의 프로세스가 실행되어야할 때 기존의 프로세스의 상태 또는 컨텍스트를 저장하고 CPU가 다음 프로세스를 실행하도록 새로운 프로세스 상태 또는 컨텍스트를 교체하는 작업을 말합니다. 

컨텍스트는 CPU가 해당 프로세스를 실행하기 위한 프로세스들의 정보이고, 보통 프로세스의 PCB(Process Control Block)에 저장됩니다.

<br><br><br>

## 스레드에서 컨텍스트 스위칭에 대해 설명해주세요.

<br>

💡 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 프로세스 컨텍스트 스위칭보다 비용이 더 적고 시간도 더 적게 걸립니다.

<br><br><br>

## 멀티 스레드의 동시성과 병렬성을 설명해주세요.

<br>

💡 **동시성**은 싱글 코어에서 여러 개의 쓰레드가 번갈아 실행하여 마치 동시에 실행하는 것처럼 보이게하는 것을 말하고, **병렬성**은 멀티 코어에서 한 개 이상의 스레드를 포함하는 각 코어들을 동시에 실행하는 것을 말합니다.

<br><br><br>

## 멀티 프로그래밍과 멀티 태스킹의 차이점을 설명해주세요.

<br>

💡 **멀티 프로그래밍**은 메모리에 CPU를 적재하여 실행하다가 입출력 작업이 시작되면 다른 프로세스를 실행하는 방법입니다.

**멀티 태스킹**은 운영체제의 스케줄링에 의해 프로세스가 번갈아 가면서 수행되도록 하는 방법입니다.


<br><br><br>

## 데드락이 무엇인지, 데드락을 해결하려면 어떻게 해야하는지 설명해주세요.

<br>

💡 데드락(교착상태)이란 **둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황** 입니다.

데드락을 해결하기 위한 해결 방법으로는 ‘**예방**’, ‘**회피**’, ‘**검출 후 회복**’이 있습니다. 

<br>

**‘예방’**은 교착 상태가 일어나지 않도록 교착 상태 발생 조건에 부합하지 않게 자원을 분배하여 교착 상태를 예방하는 방식입니다. 

**‘회피’**는 교착 상태의 위험이 있다면 자원을 할당하지 않는 방식입니다. 

**‘검출 후 회복’**은 자원을 제약 없이 할당하다가 교착 상태가 검출되면 교착 상태를 회복하는 방식입니다.

<br><br><br>

## Deadlock의 발생 조건에 대해 설명해주세요.

<br>

💡 데드락의 발생 조건에는 **상호 배제, 점유와 대기, 비선점, 원형 대기**가 있습니다. 이 네가지 조건이 모두 만족해야 데드락이 발생합니다.

**상호 배제**는 한 프로세스가 자원을 점유해서 다른 프로세스가 사용을 못하는 상황을 말하고, **점유와 대기**는 프로세스가 자원을 점유한 상태로 다른 자원을 대기하는 상황을 말합니다. 

**비선점**은 자원을 점유한 프로세스에게 강제로 자원을 빼앗지 못하는 상황을 말하고, **원형 대기**는 프로세스들이 원의 형태로 자원을 대기하고 있는 것을 말합니다.

<br><br><br>

## 캐시 메모리가 필요한 이유는 무엇인가요?

<br>

💡 CPU가 메모리에 접근하는 시간은 CPU의 연산 속도보다 느립니다. 

이 속도 차이에 따른 병목 현상을 줄이기 위해 캐시 메모리를 사용합니다. 

CPU가 매번 메모리에 접근 하면 오래 걸리기 때문에 사용할 일부 데이터를 미리 캐시 메모리에 가지고 와서 활용하는 것입니다.

<br><br><br>

## 캐시의 지역성 원리에 대해 설명하세요.

<br>

💡 캐시는 **참조 지역성의 원리**에 따라 메모리로부터 가져올 데이터를 결정합니다. 참조 지역성의 원리란 CPU가 메모리에 접근할 때의 주된 경향을 바탕으로 만들어진 원리입니다.

<br>

참조 지역성은 **시간 지역성**과 **공간 지역성**을 따릅니다. 

**시간 지역성**은 CPU가 최근에 접근했던 메모리 공가에 다시 접근하려는 경향을 의미합니다. 

**공간 지역성**은 CPU가 접근한 메모리 공간 근처를 접근하려는 경향을 의미합니다.

<br><br><br>

## 캐시의 지역성에 대해 설명주세요.

<br>

💡 캐시는 CPU가 매번 메인 메모리에 접근해 데이터를 받아오면 시간이 오래 걸리기 때문에 자주 사용하는 데이터로 담아두고, 해당 데이터가 필요할 때 CPU가 메인 메모리가 아닌 캐시에 접근하도록하여 처리 속도를 높이기 위해 사용됩니다. 

이때 자주 사용하는 데이터에 대한 판단은 지역성의 원리를 따릅니다.

<br>

캐시의 지역성은 **시간 지역성**과 **공간 지역성**으로 나눌 수 있습니다. 

**시간 지역성**은 최근에 접근한 데이터에 다시 접근하려는 경향을 의미하고, **공간 지역성**은 최근 접근한 데이터의 주변 공간에 다시 접근하려는 경향을 의미합니다.

<br><br><br>

## 페이지 폴트(Page fault)에 대해 설명해 주세요.

<br>

💡 CPU가 프로세스를 실행하는데 원하는 페이지가 메모리에 없어서 보조기억장치에서 해당 정보를 가져와야 하는 경우를 페이지 폴트라고 합니다.


<br><br><br>

## 풀링 방식에 대해 설명하고, 인터럽트 방식과의 차이에 대해 설명해 주세요.

<br>

💡 **풀링 방식**은 CPU가 입출력장치의 변화를 지속적으로 계속 확인하는 방식이고, **인터럽트 방식**은 CPU가 인터럽트 신호를 받았을 때에만 입출력 처리를 진행합니다. 

폴링 방식은 인터럽트 방식보다 CPU의 부담이 더 큽니다.

</aside>