# 질문 리스트

<br>

> ## 💻 스케줄러를 단기, 중기, 장기로 나누는 기준은 무엇일까요? (예지)
<br>

단기 스케줄러 (=CPU 스케줄러)는 준비 상태의 프로세스 중에서 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지를 결정합니다.
중기 스케줄러는 메모리에 적재된 프로세스 수를 관리합니다.
장기 스케줄러 (= 작업 스케줄러)는 어떤 프로세스를 준비 큐에 삽입할지를 결정합니다. 장기 스케줄러는 수십 초 ~ 수분 단위로 가끔 호출되기 때문에 상대적으로 속도가 느린 것이 허용됩니다.

<br><br><br>

> ## 💻 선점형 스케줄링과 비선점형 스케줄링에 대해 설명해 주세요. (유리)
<br>

특정 프로세스가 CPU를 독점하는것이 불가능하면 선점형 스케줄링이고, 특정 프로세스가 CPU를 독점하는것이 가능하면 비선점형 스케줄링입니다. 

---
<br>

### 장 / 단점
    
**비선점형 스케줄링**은 선점 방식보다 스케줄러 호출 빈도 낮고 문맥 교환에 의한 오버헤드가 적습니다. 일괄 처리 시스템에 적합하며, CPU 사용 시간이 긴 하나의 프로세스가 CPU 사용 시간이 짧은 여러 프로세스를 오랫동안 대기시킬 수 있으므로 처리율이 떨어질 수 있다는 단점이 있습니다.

**선점형 스케줄링**은 모든 프로세스에게 CPU 사용 시간을 동일하게 부여(Round Robin - RR)할 수도 있습니다. 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하며 긴급한 프로세서를 제어할 수 있습니다.

<br><br><br>

> ## 💻 Convey 현상과 해당 현상이 발생하는 알고리즘이 무엇인지 설명해 주세요. (아람)
<br>

Convey 현상이란 CPU 사용 시간이 긴 프로세스에 의해 사용시간이 짧은 프로세스들이 오래 기다리는 상황을 말하며, 비선점형 스케줄링 알고리즘에서 나타나는 현상입니다.

<br><br><br>

> ## 💻 프로세스의 종료에는 자발적인 종료와 비자발적 종료가 있는데 비자발적 종료가 발생하는 경우를 설명해 주세요. (소연) 
<br>

부모 프로세스가 종료되었을 때와 부모 프로세스가 자식 프로세스를 강제로 종료시키는 경우, 키보드로 kill이나 break를 친 경우, 자식 프로세스가 할당 자원을 넘어선 과한 자원을 요구할 때, 자식 프로세스에게 할당된 작업이 더이상 필요하지 않을 때 비자발적 종료가 발생합니다.

<br><br><br>

> ## 💻 프로세스 스케줄링이 발생 경우 4가지에 대해 설명해 주세요. (프로세스 상태) (지윤)
<br>

실행 상태에 있던 프로세스가 I/O 요청 등에 의해 Block(Wait) 상태가 되는 경우, 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 Ready 상태로 되는 경우, I/O 작업이 완료되어 인터럽트가 발생하고, 해당 프로세스가 Ready 상태로 바뀌는 경우, CPU에서 실행 상태에 있는 프로세스가 terminate되는 경우가 있습니다.

<br><br><br>

> ## 💻 라운드로빈 스케줄링에 대해 설명해 주세요. (소연)
<br>

라운드로빈 스케줄링은 FCFS와 타임 슬라이스 기법을 합친 스케줄링 방식입니다.
타임 슬라이스만큼 프로세스가 실행 되고, 다음 실행될 프로세스는 가장 먼저 준비 큐에 들어온 프로세스가 선택됩니다.

<br><br><br>

> ## 💻 우선순위 스케줄링의 문제점과 해결방안에 대해 설명해 주세요. (아람)
<br>

우선순위 스케줄링 시 우선순위가 낮은 프로세스가 CPU 할당을 오랜 시간동안 기다리는 무한대기 또는 기아 현상(starvation)이 발생할 수 있습니다.
이를 해결하기 위한 방법은 에이징(Aging) 기법으로, 우선순위가 낮은 프로세스가 무한정 기다리는 현상을 방지하기 위해 기다린 시간만큼 우선순위 단계를 높여주는 방법입니다.

<br><br><br>

> ## 💻 좀비 프로세스와 고아 프로세스에 대해 설명해 주세요. (유리)
<br>

좀비 프로세스란 자식 프로세스가 부모 프로세스보다 먼저 종료되는 경우를 말하고, 고아 프로세스는 부모 프로세스가 자식 프로세스보다 먼저 종류되는 경우를 말합니다.

---
<br>

### 좀비 프로세스

자식 프로세스가 부모 프로세스보다 먼저 죽는 경우 부모 프로세스가 종료 상태를 회수하기 위해 커널이 자식 프로세스의 최소한의 정보(PID, 종료 상태 등, 리눅스의 경우 커널에서 사용하는 구조체)를 남겨둡니다.
부모 프로세스는 wait 함수를 호출하여 이 상태를 회수하면 남은 모든 정보가 제거되어 자식 프로세스는 완전히 소멸하게 됩니다.
위와 같은 진행상황에서 부모 프로세스가 wait 함수를 호출하지 않아 최소한의 정보가 메모리에 남아 있는 경우를 좀비 프로세스라고 합니다. 
좀비 프로세스는 최소한의 정보만을 가지고 있어 큰 성능 저하를 야기하지 않지만, 운영체제는 한정된 PID를 가지고 있으므로 좀비 프로세스가 PID를 차지하며 다른 프로세스 실행을 방해하게 됩니다.
따라서 부모 프로세스는 좀비 프로세스 생성을 방지하기 위해 wait 함수를 호출하여 상태를 회수하여야 합니다.

<br>

### 고아 프로세스

부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우 부모 프로세스가 없는 자식 프로세스를 말합니다.
운영체제는 이러한 고아 프로세스를 허용하지 않으며 부모 프로세스가 먼저 종료되면 자식 프로세스의 새로운 부모 프로세스로 init(PID = 1)가 설정됩니다.
init 프로세스는 자식 프로세스가 종료될 때까지 기다린 후 wait 함수를 호출하여 고아 프로세스의 종료 상태를 회수하여 좀비 프로세스가 되는 것을 방지합니다.
고아 프로세스는 프로세스 자신이 시스템의 자원을 낭비할 수 있고, 시스템이 프로세스가 종료될 때까지 추적을 해야 하기 때문에 성능 저하의 원인이 됩니다.

<br><br><br>

> ## 💻 CPU 스케줄링 알고리즘이 필요한 이유가 무엇일까요? (예지)
<br>

운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하기 위해서 CPU 스케줄링 알고리즘이 필요합니다.

<br><br><br>

> ## 💻 다단계 큐 스케줄링과 다단계 큐 피드백 스케줄링에 대해 설명해주시고 차이점을 이야기해주세요 (지윤)
<br>

**다단계 큐 스케줄링**은 우선순위 별로 준비 큐를 분리해 놓은 스케줄링입니다. 프로세스는 큐 사이를 이동할 수 없습니다. 

**다단계 피드백 큐 스케줄링**은 다단계 큐와 형식은 같지만 프로세스가 큐 사이를 이동할 수 있습니다. 다단계 큐에서 발생하는 기아 현상을 방지하기 위해 에이징 기법을 활용할 수 있습니다.