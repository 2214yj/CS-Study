# 질문 리스트

<br>

> ## 💻 검색을 구현할 수 있는 자료구조 또는 알고리즘을 이야기해주세요. (유리)
<br>

검색에는 선형 검색과 이진 검색을 활용할 수 있습니다. 선형 검색은 배열의 맨 앞부터 순서대로 요소를 검색하는 방식으로 O(n)의 시간복잡도를 가지며, 이진검색은 테이터가 정렬되어있는 배열에서 원하는 값을 찾아낼 수 있는 알고리즘으로, 배열의 중간에 있는 임의의 값을 선택하여 원하는 값과 비교합니다. 원하는 값이 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로 다시 탐색하고, 원하는 값이 중간 값보다 크면 중간 값을 기준으로 우측의 데이터들을 대상으로 다시 탐색합니다. 시간복잡도는 O(logN) 입니다.


<br><br><br>

> ## 💻 해쉬 테이블에 대해 설명해주세요. (지윤)
<br>

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조입니다. Key값에 해시함수를 적용해 index를 생성하고 이 index에 값을 저장하면 됩니다.

<br><br><br>

> ## 💻 해쉬 충돌이 일어날 때 해결방법 2가지에 대해 설명해주세요. (소연)
<br>

해쉬 충돌은 체인법과 오픈 주소법으로 해결할 수 있습니다.
체인법은 해시값이 같은 데이터를 체인 모양의 연결 리스트로 연결합니다. 오픈 주소법은 충돌이 발생했을 때 재해싱을 수행하여 빈 버킷을 찾는 방법으로, 빈 버킷이 나올 때까지 해싱을 반복합니다.

<br><br><br>

> ## 💻 해시법에서 시간 복잡도를 설명해주세요.(예지)
<br>

해시 테이블의 평균 시간 복잡도는 O(1)이고 최악 시간 복잡도는 O(N)입니다.
해싱 함수를 통한 한번의 연산으로 key에 따른 value를 찾을 수 있기 때문에, 해시 테이블의 평균 시간 복잡도는 O(1)입니다. 해시 충돌 발생 시 탐색 시간 복잡도가 O(N)에 점점 수렴하게 됩니다.  

<br><br><br>

> ## 💻 빅오, 빅세타, 빅오메가에 대해 설명해주세요. (소연)
<br>

빅오는 최악의 경우 시간복잡도를 의미하고, 빅오메가는 최선의 경우 시간복잡도를 의미합니다. 빅세타는 빅오와 빅오메가의 공통부분입니다. 최소와 최악의 중간인 평균적인 시간복잡도를 의미합니다.  

<br><br><br>

> ## 💻 이진 검색에서의 동작 과정에 대해 설명해주세요. (지윤)
<br>

이진 검색은 정렬된 리스트에서 이루어집니다. 먼저 배열의 중간 값을 가져와서 구하고자 하는 검색 값을 비교합니다. 만약 검색값이 중간값보다 작다면 왼쪽 구간을 대상으로, 크다면 오른쪽 구간을 대상으로 탐색합니다. 위 과정을 값을 찾거나 간격이 비어있을 때까지 반복합니다.  

<br><br><br>

> ## 💻 해시와 해시 함수에서 발생하는 문제(Space-Time trade off)에 대해 설명해주세요. (유리)
<br>

해시 테이블을 크게 하면 충돌 발생을 억제할 수 있어 검색, 추가, 삭제의 시간을 줄일 수 있지만  테이블의 크기를 늘리는 만큼 메모리를 많이 사용하게되는 것을 말합니다. 충돌을 피하려면 해시 함수는 해시 테이블 용량 이하의 정수를 고르게 만들어 내야 하는데, 해시 테이블의 용량은 소수가 좋다고 알려져 있습니다.  

<br><br><br>

> ## 💻 체인법 방식으로 조회할 때 worst case의 시간 복잡도가 O(n)인 이유를 설명해주세요. (예지)
<br>

체이닝 방식은 해시값이 같은 데이터를 사슬(chain) 모양의 연결 리스트로 연결하는 방법이다. 원하는 key를 가지고 있는 노드가 있는지 선형 탐색을 한다. n개의 동일한 key를 갖는 value를 탐색할 때 최악의 경우, n번의 탐색 과정을 거치게 된다. 따라서 체인법 방식으로 조회할 때 worst case의 시간 복잡도가 O(n)이다.

<br><br><br>

---
# 자바 심화 질문
> ## 💻 HashMap은 어떤 해시 충돌을 사용하나요? (예지)
<br>

HashMap에서 사용하는 충돌 해결 방법은 Seperate Chaining 방식입니다.
Open Addressing은 데이터를 삭제할 때 효율적으로 처기하기 어렵기 때문입니다. 그 이유는 HashMap에서 remove() 메서드가 빈번하게 호출될 수 있기 때문입니다.
게다가, HashMap에 저장된 key-value 쌍의 개수가 일정 이상으로 많아지면, 일반적으로 Open Addressing은 Seperate Chaining보다 느려집니다. Open Addressing은 버킷의 밀도가 높아질수록 Worst Case의 빈도가 높아지지만, Chaining은 해시 충돌이 잘 발생하지 않도록 조정하면 Worst Case를 줄일 수 있습니다.(자바는 Worst Case를 줄이기 위해 보조 해시 함수를 사용합니다.)

데이터 개수가 많아지면, Seperate Chaining에서는 링크드 리스트 대신 트리를 사용하여 성능을 높입니다. JAVA 8을 기준으로 HashMap에서는 하나의 해시 버킷에 8개의 키-값 쌍이 모이면 링크드 리스트를 트리로 변경합니다. 트리는 링크드리스트보다 메모리 사용량이 많고, 데이터의 개수가 적을 때  링크드 리스트의 Worst Case 수행 시간 차이 비교는 의미가 없기 때문입니다.

---
<br>

- Open Addressing은 이미 자리에 누군가가 있으면 다른 곳으로 배정하는 방식입니다. 다른 곳에 배정하는 방식에 따라 Linear Probing과 Quadratic Probing 등의 방법이 있습니다.
- Separate Chaining은 해시 테이블의 구조를 변경하여 하나 이상의 키값을 저장할 수 있도록 하는 방법입니다. 이때 주로 사용하는 자료구조로 연결 리스트를 사용합니다.

[참고자료]  
[https://tecoble.techcourse.co.kr/post/2021-11-05-hash-hashmap/](https://tecoble.techcourse.co.kr/post/2021-11-05-hash-hashmap/)  
[https://d2.naver.com/helloworld/831311](https://d2.naver.com/helloworld/831311)
<br><br><br>

> ## 💻 HashMap과 HashTable의 차이에 대해 설명해주세요. (예지)
<br>

HashMap과 HashTable의 차이는 동기화 지원 여부에 있습니다.
병렬처리를 하면서 자원의 동기화를 고려해야 하는 상황이라면 동기화를 지원하는 HashTable을 사용해야 하며, 병렬처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황이라면 동기화를 지원하지 않는 HashMap을 사용하면 됩니다.
HashTable보다 새로운 버전인 HashMap을 사용할 것을 권합니다.  

<br><br><br>

> ## 💻 배열과 리스트의 정의와 차이점에 대해 설명해주세요. (유리)
<br>

**배열(Array)**   
같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조입니다. 만약 다른 타입의 값을 저장하려고 하면 타입 불일치(Type mismatch) 컴파일 오류가 발생합니다. 그리고 한 번 생성된 배열은 길이를 늘리거나 줄이거나 할 수 없습니다.  
<br>

**리스트(List)**  
배열의 문제점을 해결하기 위한 자료구조입니다.
배열에서 인덱스는 유일무이한 식별자이지만 리스트에서는 몇 번째 데이터인지 정도의 의미를 가집니다.
객체를 일렬로 늘어놓은 구조를 가집니다. 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공합니다. List는 객체의 번지를 참조합니다. null도 저장이 가능하며, 이 경우에는 해당 인덱스는 객체를 참조하지 않음을 의미합니다.  
<br>

**차이점**  
배열은 배열의 길이를 변경할 수 없지만 리스트는 길이를 변경할 수 있으며 제네릭을 사용할 수 있습니다. 또한 배열은 다차원 배열을 생성할 수 있지만 리스트는 다차원 배열을 사용할 수 없습니다. 속도적인 측면에서는 배열은 초기화 시 메모리에 할당되어 속도가 빠르며, List는 추가 시 메모리를 재할당하기 때문에 속도가 느립니다.  
또한 배열은 Compile time에 할당되는 정적으로 메모리 할당하고, 리스트는 새로운 Node가 추가되는 runtime에 할당되는 동적 메모리 할당합니다.    

    - 런타임 : 컴파일 과정을 마친 응용 프로그램이 사용자에 의해 실행될 때
    - 컴파일 타임 : 소스 코드가 컴파일을 통해 기계어 코드로 변환되어 실행 가능한 프로그램이 되는 편집 과정


---
<br>

![Untitled (1)](https://user-images.githubusercontent.com/54930365/216871871-ff880534-2b4a-4b10-b710-ee4e061eca37.png)


<br><br><br>
